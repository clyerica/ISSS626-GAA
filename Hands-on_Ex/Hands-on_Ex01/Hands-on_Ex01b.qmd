---
title: "Choropleth Mapping with R"
author: "Erica Chan"
---

This page will cover plotting functional and truthful choropleth maps using the tmap package.

# 1. Getting Started

## 1.1 Installing R packages

This exercise uses the following packages:

-   **readr** for importing delimited text files
-   **tidyr** for tidying data
-   **dplyr** for wrangling data
-   **sf** for handling geospatial data
-   **rvest** for scraping (or harvesting) data from web pages

**readr**, **tidyr** and **dplyr** are part of the tidyverse package. The following code chunk install and loads the aforementioned packages in RStudio

```{r}
pacman::p_load(sf, tmap, tidyverse, rvest)
```

## 1.2 Importing data into R

The following datasets will be used to create the choropleth map:

1.  Master Plan 2019 Subzone Boundary (No Sea) (KML). This consists of the geographical boundary of Singapore at the planning subzone level, based on the URA Master Plan 2019
2.  Singapore Residents by Planning Area/Subzone, Age Group, Sex and Type of Dwelling, June 2024 (csv). This is an aspatial data file with PA and SZ fields which can be used as unique identifiers to georeference to Master Plan 2019 Subzone Boundary.

## 1.2.1 Importing Geospatial Data into R

The following code chunk uses `st_read()` function of **sf** package to import the subzone shapefile into R as a simple feature dataframe as `mpsz`.

```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```

### 1.2.2 Tidying data

The following code chunk extracts values from the HTML description

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz <- mpsz %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

The content of mpsz can be examined below

```{r}
mpsz
```

Only ten records are displayed as there are too many records, displaying only the first ten is the default behaviour for performance.

## 1.3 Importing Attribute Data into R

The `read_csv()` function of **readr** package will be used to import the csv file into RStudio and save the content into a tibble dataframe called `popdata`.

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2024.csv")
```

## 1.4 Data Preparation

To create the thematic map, a data table will be created with the relevant values. The data table will include the following variables:

-   YOUNG: age group 0 to 4 until age group 20 to 24,

-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,

-   AGED: age group 65 and above,

-   TOTAL: all age group, and

-   DEPENDENCY: the ratio between young and aged against economy active group

### 1.4.1 Data wrangling

The following functions will be used:

-   `pivot_wider()` of **tidyr** package, and
-   `mutate()`, `filter()`, `group_by()` and `select()` of **dplyr** package

```{r}
popdata2024 <- popdata %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)
```

### 1.4.2 Joining attribute and geospatial data

First, the PA and SZ fields must be converted to uppercase to match the SUBZONE_N and PLN_AREA_N fields

```{r}
popdata2024 <- popdata2024 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

Next, `left_join()` of **dplyr** is used to going the geographical data and attribute table, using the planning subzone name as the common key

-   `left_join()` is used with mpsz simple feature data frame as the first argument, to ensure that the output will be a simple feature data frame

```{r}
mpsz_pop2024 <- left_join(mpsz, popdata2024,
                          by = c("SUBZONE_N" = "SZ"))
```

```{r}
write_rds(mpsz_pop2024, "data/rds/mpsz_pop2024.rds")
```

# 2. Choropleth Mapping Geospatial Data with tmap

Choropleth mapping involves the symbolisation of enumeration units, such as countries, provinces, states, counties or census units, using area patterns or graduated colors. Thematic maps can be prepared either quickly using qtm(), or done with customisation using tmap elements

## 2.1 Plotting with *qtm()*

The easiest and quickest to draw a choropleth map using tmap is using qtm(). It is concise and provides a good default visualisation in many cases.

```{r}
tmap_mode("plot")
qtm(shp=mpsz_pop2024,
    fill="DEPENDENCY")
```

-   `tmap_mode()` with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.
-   `fill` argument is used to map the attribute (i.e. DEPENDENCY)

## 2.2 Plot a choropleth map using *tmap*'s elements

`qtm()` makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, **tmap**’s drawing elements should be used.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_title("Distribution of Dependency Ratio by planning subzone") +
  tm_layout(frame = TRUE) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

The following subsection will cover the tmap functions used to plot the elements

### 2.2.1 Base map

The basic building block of **tmap** is `tm_shape()` followed by one or more layer elements such as `tm_polygons()`, `tm_symbols()`, `tm_lines()`, `tm_raster()` and `tm_text()`.

In the code chunk below, `tm_shape()` is used to define the input data (i.e mpsz_pop2024) and `tm_polygons()` is used to draw the planning subzone polygons

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons()
```

### 2.2.2 *tm_polygons()*

By assigning a target variable to `tm_polygons()`, such as `Dependency`, the geographical distribution of the variable by planning subzone will be displayed

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill="DEPENDENCY")
```

### 2.2.3 *tm_fill()* and *tm_border()*

`tm_fill()` shades the polygons by using the default colour scheme and tm_borders() adds the borders of the polygon features onto the choropleth map.

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY")
```

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders()
```

The `fill_alpha` argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).

Beside `fill_alpha` argument, there are three other arguments for tm_borders(), they are:

-   `col` = border colour,
-   `lwd` = border line width. The default is 1, and
-   `lty` = border line type. The default is “solid”

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders(col = "grey60",
             lwd = 0.1,
             lty = "dashed")
```

## 2.3 Data classification methods of tmap

**tmap** provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.

To define a data classification method, the style argument of `tm_fill()` or `tm_polygons()` will be used.

### 2.3.1 Plotting choropleth maps with built-in classification methods

The following code chunk shows a 5-class quantile data classification

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

The following code chunk shows a 10-class quantile data classification

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 10)) +
  tm_borders(fill_alpha = 0.5)
```

The following code chunk uses the equal data classification method using 15 classes

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 15)) +
  tm_borders(fill_alpha = 0.5)
```

The following code chunk uses the sd classification method

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "sd",
                n = 6)) +
  tm_borders(fill_alpha = 0.5)
```

### 2.3.2 Plotting choropleth maps with custom break

For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the `tm_scale_intervals()`.

It is important to note that in **tmap**, the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).

The code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field before setting the break points

```{r}
summary(mpsz_pop2024$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus `c(0, 0.60, 0.70, 0.80, 0.90, 1.00)`

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +
  tm_borders(fill_alpha = 0.5)
```

## 2.4 Colour Scheme

**tmap** supports colour ramps either defined by the user or a set of predefined colour ramps from the **RColorBrewer** package.

### 2.4.1 Using ColourBrewer palette

To change the colour, we assign the preferred colour to palette argument of values as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.reds")) +
  tm_borders(fill_alpha = 0.5)
```

to reverse the colour shading, add a"-" prefix before the value argument

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.reds")) +
  tm_borders(fill_alpha = 0.5)
```

### 2.4.2 Cartographic furniture

Beside map style, **tmap** also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below, `tm_compass()`, `tm_scale_bar()`, `tm_grid()` and `tm_credit()` are used to add compass, scale bar, grid lines and data sources onto the choropleth map.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

## 2.5 Map Layout

The layout includes the map background, frame, typography, scale, aspect ratio, margins, and more.

We can customize the map layout using the `tm_layout()` function. In this section, we will cover the most often used arguments of this function using the dependency choropleth map as example.

### 2.5.1 Legend

`tmap_legend()` options in **tmap** can change the placement format and appearance of the legend

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_pos_auto_in() +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

### 2.5.2 Map Style

`tmap_style()` allows for layout settings to be changed.

The code chunk below shows the natural style

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("natural")
```

The following code chunk resets to the default style

```{r}
tmap_style("white")
```

# 3. Drawing Small Multiple Choropleth Maps

Small multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

In **tmap**, small multiple maps can be plotted in three ways:

## 3.1 Assigning multiple values to at least one of the aesthetic arguments

The following code chunk creates small multiple choropleth maps by assigning two variables to the visual variable (i.e. fill).

```{r}
tm_shape(mpsz_pop2024) + 
  tm_polygons(
    fill = c("YOUNG", "AGED"),
    fill.legend = 
      tm_legend(position = tm_pos_in(
        "right", "bottom")),
    fill.scale = tm_scale_intervals(
      style = "equal", 
      n = 5,
      values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tmap_style("natural")
```

## 3.2 Arranging multiple chloropleth maps in a grid layout

The following code chunk creates multiple choropleth maps and uses tmap_arrange() to arrange them in a grid layout

```{r}
youngmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "YOUNG",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                  item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")
                
agedmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "AGED",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
              style = "quantile", 
              values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of aged population")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```

## 3.3. Defining a group-by variable in *tm_facets()*

The following code chunk uses `tm_facets()` to create multiple small choropleth maps

```{r}
tm_shape(mpsz_pop2024) +
  tm_fill(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile",
            values = "brewer.blues")) + 
  tm_facets(by = "REGION_N",
            nrow = 2, 
            ncols = 3,
            free.coords=TRUE, 
            drop.units=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(fill_alpha = 0.5)
```

# 4. Mapping Spatial Objects That Meet a Selection Criterion

`filter()` of **dplyr** package can be used to select geographical area of interest and plot a choropleth map focusing only on the selected region.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend()) +
  tm_borders(fill_alpha = 0.5)
```

# 5. Complementing Thematic Maps with a Statistical Chart

With **tmap**, statistical charts can be incorporated into the map visualisation by using `fill.chat` argument of map layers and legend chart feature as shown in the code chunk below.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) +
  tm_borders() +
  tm_layout(asp = 0.8)
```

The visual representation is further improved by highlighting and labelling the outliers in the choropleth map as in the code chunk below

```{r}
mpsz_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")

stats <- boxplot.stats(mpsz_selected$DEPENDENCY)

outlier_vals <- stats$out

outlier_sf <- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]

tm_shape(mpsz_selected) +
  tm_polygons(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile", 
            values = "brewer.blues"),
          fill.legend = tm_legend(),
          fill.chart = tm_chart_box()) +
  tm_borders(fill_alpha = 0.5) +
tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_text("SUBZONE_N", col = "red", size = 0.7) +
  tm_layout(asp = 0.8)
```

# 6. Creating an Interactive Map

Using `tmap_mode()` allows the user to switch between static and interactive maps. The code chunk in section 4 can be modified to create an interactive map as follows:

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2)
```
